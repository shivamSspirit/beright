/**
 * Test Development Skill
 *
 * Helps Builder agent generate and run tests for the codebase.
 */

import { SkillResponse, Mood } from '../types/index';
import * as fs from 'fs';
import * as path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

const ROOT = path.join(__dirname, '..');
const SKILLS_DIR = path.join(ROOT, 'skills');

// Test template
const TEST_TEMPLATE = (skillName: string, exports: string[]) => `/**
 * Tests for ${skillName}.ts
 * Auto-generated by BeRight Builder
 */

import { describe, it, expect, vi, beforeEach } from 'vitest';
${exports.map(e => `import { ${e} } from './${skillName}';`).join('\n')}

describe('${skillName}', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

${exports.map(e => `
  describe('${e}', () => {
    it('should be defined', () => {
      expect(${e}).toBeDefined();
    });

    it('should return a SkillResponse', async () => {
      const result = await ${e}();
      expect(result).toHaveProperty('text');
      expect(result).toHaveProperty('mood');
    });
  });
`).join('\n')}
});
`;

/**
 * Generate a test file for a skill
 */
export async function generateTest(skillName: string): Promise<SkillResponse> {
  const skillPath = path.join(SKILLS_DIR, `${skillName}.ts`);
  const testPath = path.join(SKILLS_DIR, `${skillName}.test.ts`);

  if (!fs.existsSync(skillPath)) {
    return {
      text: `Skill ${skillName} not found`,
      mood: 'ERROR' as Mood,
    };
  }

  if (fs.existsSync(testPath)) {
    return {
      text: `Test file already exists: ${testPath}`,
      mood: 'ALERT' as Mood,
    };
  }

  try {
    // Parse exports from skill file
    const content = fs.readFileSync(skillPath, 'utf-8');
    const exportMatches = content.match(/export (?:async )?function (\w+)/g) || [];
    const exports = exportMatches
      .map(e => e.replace(/export (?:async )?function /, ''))
      .filter(e => !e.startsWith('_')); // Skip private functions

    if (exports.length === 0) {
      // Try to find default export
      if (content.includes('export default')) {
        exports.push(skillName);
      } else {
        return {
          text: `No exports found in ${skillName}`,
          mood: 'ERROR' as Mood,
        };
      }
    }

    const testContent = TEST_TEMPLATE(skillName, exports);
    fs.writeFileSync(testPath, testContent);

    return {
      text: `Generated test file: ${testPath}\nExports tested: ${exports.join(', ')}`,
      mood: 'BULLISH' as Mood,
      data: { path: testPath, exports },
    };
  } catch (error) {
    return {
      text: `Failed to generate test: ${error}`,
      mood: 'ERROR' as Mood,
    };
  }
}

/**
 * Generate tests for all untested skills
 */
export async function generateAllTests(): Promise<SkillResponse> {
  const skills = fs.readdirSync(SKILLS_DIR)
    .filter(f => f.endsWith('.ts') && !f.includes('.test.') && !f.includes('SKILL'))
    .map(f => f.replace('.ts', ''));

  const results: Array<{ skill: string; success: boolean; message: string }> = [];

  for (const skill of skills) {
    const testPath = path.join(SKILLS_DIR, `${skill}.test.ts`);
    if (!fs.existsSync(testPath)) {
      const result = await generateTest(skill);
      results.push({
        skill,
        success: result.mood !== 'ERROR',
        message: result.text,
      });
    }
  }

  const generated = results.filter(r => r.success).length;
  const failed = results.filter(r => !r.success).length;

  return {
    text: `Generated ${generated} test files, ${failed} failed\n\n${results.map(r => `- ${r.skill}: ${r.success ? 'OK' : 'FAILED'}`).join('\n')}`,
    mood: failed > 0 ? 'ALERT' as Mood : 'BULLISH' as Mood,
    data: { generated, failed, results },
  };
}

/**
 * Run all tests
 */
export async function runTests(pattern?: string): Promise<SkillResponse> {
  try {
    const cmd = pattern
      ? `cd ${ROOT} && npx vitest run ${pattern} 2>&1`
      : `cd ${ROOT} && npx vitest run 2>&1`;

    const { stdout, stderr } = await execAsync(cmd, { timeout: 120000 });
    const output = stdout + stderr;

    // Parse test results
    const passMatch = output.match(/(\d+) passed/);
    const failMatch = output.match(/(\d+) failed/);
    const passed = passMatch ? parseInt(passMatch[1]) : 0;
    const failed = failMatch ? parseInt(failMatch[1]) : 0;

    if (failed > 0 || output.includes('FAIL')) {
      return {
        text: `Tests failed: ${failed} failed, ${passed} passed\n\n${output.slice(-2000)}`,
        mood: 'ERROR' as Mood,
        data: { passed, failed, output },
      };
    }

    return {
      text: `All tests passed: ${passed} tests`,
      mood: 'BULLISH' as Mood,
      data: { passed, failed: 0 },
    };
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : String(error);
    // Vitest might exit with non-zero for test failures
    if (errorMsg.includes('FAIL') || errorMsg.includes('failed')) {
      return {
        text: `Tests failed:\n${errorMsg.slice(-2000)}`,
        mood: 'ERROR' as Mood,
      };
    }
    return {
      text: `Test run failed: ${error}`,
      mood: 'ERROR' as Mood,
    };
  }
}

/**
 * Run TypeScript type check
 */
export async function typeCheck(): Promise<SkillResponse> {
  const results: Array<{ dir: string; success: boolean; errors: number }> = [];

  // Check backend
  try {
    await execAsync(`cd ${ROOT} && npx tsc --noEmit 2>&1`);
    results.push({ dir: 'beright-ts', success: true, errors: 0 });
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : String(error);
    const errorCount = (errorMsg.match(/error TS/g) || []).length;
    results.push({ dir: 'beright-ts', success: false, errors: errorCount });
  }

  // Check frontend
  const frontendRoot = path.join(ROOT, '..', 'berightweb');
  try {
    await execAsync(`cd ${frontendRoot} && npx tsc --noEmit 2>&1`);
    results.push({ dir: 'berightweb', success: true, errors: 0 });
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : String(error);
    const errorCount = (errorMsg.match(/error TS/g) || []).length;
    results.push({ dir: 'berightweb', success: false, errors: errorCount });
  }

  const allPassed = results.every(r => r.success);
  const totalErrors = results.reduce((sum, r) => sum + r.errors, 0);

  return {
    text: allPassed
      ? 'Type check passed for all projects'
      : `Type check failed: ${totalErrors} errors\n${results.map(r => `- ${r.dir}: ${r.success ? 'OK' : `${r.errors} errors`}`).join('\n')}`,
    mood: allPassed ? 'BULLISH' as Mood : 'ERROR' as Mood,
    data: { results, totalErrors },
  };
}

/**
 * Run linting
 */
export async function lint(): Promise<SkillResponse> {
  try {
    const { stdout, stderr } = await execAsync(`cd ${ROOT} && npx eslint . --ext .ts,.tsx 2>&1`);
    const output = stdout + stderr;

    if (output.includes('error') && !output.includes('0 errors')) {
      const errorMatch = output.match(/(\d+) error/);
      const errors = errorMatch ? parseInt(errorMatch[1]) : 1;
      return {
        text: `Lint failed: ${errors} errors\n\n${output.slice(-1500)}`,
        mood: 'ERROR' as Mood,
        data: { errors },
      };
    }

    return {
      text: 'Lint passed',
      mood: 'BULLISH' as Mood,
    };
  } catch (error) {
    return {
      text: `Lint check failed: ${error}`,
      mood: 'ERROR' as Mood,
    };
  }
}

/**
 * Full validation: typecheck + tests
 */
export async function validate(): Promise<SkillResponse> {
  const results: string[] = [];
  let allPassed = true;

  // Type check
  const typeResult = await typeCheck();
  results.push(`TypeCheck: ${typeResult.mood === 'BULLISH' ? 'PASSED' : 'FAILED'}`);
  if (typeResult.mood !== 'BULLISH') allPassed = false;

  // Tests (if vitest is configured)
  try {
    const testResult = await runTests();
    results.push(`Tests: ${testResult.mood === 'BULLISH' ? 'PASSED' : 'FAILED'}`);
    if (testResult.mood !== 'BULLISH') allPassed = false;
  } catch {
    results.push('Tests: SKIPPED (vitest not configured)');
  }

  return {
    text: `Validation ${allPassed ? 'PASSED' : 'FAILED'}\n\n${results.join('\n')}`,
    mood: allPassed ? 'BULLISH' as Mood : 'ERROR' as Mood,
    data: { results, allPassed },
  };
}

/**
 * Get test coverage summary
 */
export async function coverage(): Promise<SkillResponse> {
  try {
    const { stdout } = await execAsync(`cd ${ROOT} && npx vitest run --coverage 2>&1`, {
      timeout: 180000,
    });

    // Parse coverage output
    const coverageMatch = stdout.match(/All files\s+\|\s+([\d.]+)/);
    const coverage = coverageMatch ? parseFloat(coverageMatch[1]) : 0;

    return {
      text: `Test coverage: ${coverage}%\n\n${stdout.slice(-2000)}`,
      mood: coverage >= 70 ? 'BULLISH' as Mood : coverage >= 50 ? 'NEUTRAL' as Mood : 'ALERT' as Mood,
      data: { coverage },
    };
  } catch (error) {
    return {
      text: `Coverage check failed: ${error}`,
      mood: 'ERROR' as Mood,
    };
  }
}

// Main export
export async function devTest(command?: string, ...args: string[]): Promise<SkillResponse> {
  switch (command) {
    case 'generate':
      return generateTest(args[0]);
    case 'generate-all':
      return generateAllTests();
    case 'run':
      return runTests(args[0]);
    case 'typecheck':
      return typeCheck();
    case 'lint':
      return lint();
    case 'validate':
      return validate();
    case 'coverage':
      return coverage();
    default:
      return {
        text: `Test Dev Skill Commands:
- generate <skill> - Generate test for a skill
- generate-all - Generate tests for all untested skills
- run [pattern] - Run tests (optional pattern filter)
- typecheck - Run TypeScript check
- lint - Run ESLint
- validate - Full validation (typecheck + tests)
- coverage - Run tests with coverage`,
        mood: 'EDUCATIONAL' as Mood,
      };
  }
}

export default devTest;

// CLI support
if (require.main === module) {
  const args = process.argv.slice(2);
  devTest(args[0], ...args.slice(1)).then(result => {
    console.log(result.text);
    process.exit(result.mood === 'ERROR' ? 1 : 0);
  });
}
